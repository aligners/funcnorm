function TW = computeInterpInVolume(sub, coords, warp, experiment)

% This file is part of the Functional Normalization Toolbox, (c) 2008 by the authors.
% Please see AUTHORS and LICENSE file in the project root directory

inputDir='../../swaroop/input_data';
saveSubjDir='../../swaroop/subjects_dir';
surfvol=[saveSubjDir,'/',sub,'/funcnorm/',experiment,'/',sub,'_SurfVol_Alnd_Exp+orig.BRIK'];
fs_surf='sphere.reg';
[res,tmpDir]=system('mktemp -d');
tmpDir = strtrim(tmpDir);
tmpDir
mmRes=2;
func3d=[inputDir,'/',sub,'_func_',experiment,'+orig.BRIK.gz'];
opsDataType='single';
saveDataType='single';

% Make sure that cartCoords are normalized
if abs(sqrt(sum(coords.cartCoords(:,1).^2))-1) > 1e-5
	error('cart coords should be normalized!');
end
if size(coords.cartCoords, 2) ~= size(warp, 2)
	error('coords and warp are not compatible');
end

warpCoordsFull = coords.cartCoords + warp;
warpTrisFull = coords.triangles;

% call make_warped_meshes*
hems={'lh','rh'};

N = size(warpCoordsFull,2) / 2;
nT = size(warpTrisFull,2) / 2;
for h=1:2
	warpCoords=warpCoordsFull(:,((h-1).*N+1):h.*N);
	warpTris=warpTrisFull(:,((h-1).*nT+1):h.*nT);
	
	hem=hems{h};
	disp(['subject ',sub,' ',hem,' hemisphere...']);
	
	orig_prefix=[saveSubjDir,'/',sub,'/SUMA/',hem,'.'];
	orig_sphere=[orig_prefix,fs_surf,'.asc'];
	orig_pial=[orig_prefix,'pial.asc'];
	orig_smoothwm=[orig_prefix,'smoothwm.asc'];	
	
	% Find nearest node in orig_sphere from warp_sphere
	origCoords = read_fs_ascii_mesh(orig_sphere);
	nearest_nodes = zeros(N, 1);
	disp('finding nearest nodes...');
	for n = 1:N
		corrs = warpCoords(:, n)'*origCoords;
		% Find node with max correlation
		[garbage, nearest_nodes(n)] = max(corrs);
		if ~mod(n,1000)
		  fprintf('%d / %d\n',n,N);
		end
	end
	
	% use nearest nodes to get rows of X Y Z from orig_pial and orig_smoothwm
	% and tesselate to get triangles for topological section of
	% mesh
	origCoords = read_fs_ascii_mesh(orig_smoothwm);
	warpPrefix=[tmpDir,'/',sub,'_',hem];
	warp_sphere=[tmpDir, '/','standard',num2str(mmRes),'mm_',sub,'_',hem,'.connnorm.asc'];
	fp = fopen(warp_sphere, 'w');
		fprintf(fp, '#\n');
		fprintf(fp, '%d %d\n', size(warpCoords, 2), size(warpTris, 2));
		fprintf(fp, '%f %f %f 0\n', 100*warpCoords);
		fprintf(fp, '%d %d %d 0\n', warpTris);
	fclose(fp);
	
	smoothwm=[warpPrefix,'.smoothwm.connnorm.asc'];
	make_warped_nonsphere(origCoords,warpTris,nearest_nodes,smoothwm);
	origCoords = read_fs_ascii_mesh(orig_pial);
	pial=[warpPrefix,'.pial.connnorm.asc'];
	make_warped_nonsphere(origCoords,warpTris,nearest_nodes,pial);
	
	% make a spec file with warp_sphere, warp_pial, warp_smoothwm in it
	surfspec=[warpPrefix,'.spec'];
	fid = fopen(surfspec,'w');
	fprintf(fid,'# generated by computeInterpInVolume.m, part of connnorm\n');
	fprintf(fid,'\tGroup = %s_%s_connnormed\n',sub,hem);
	fprintf(fid,'\tStateDef = %s\n',fs_surf);
	fprintf(fid,'\tStateDef = pial\n');
	fprintf(fid,'\tStateDef = smoothwm\n');
	fprintf(fid,'\n\n');
	write_spec_surface(fid,sub,hem,'smoothwm',mmRes);
	fprintf(fid,'\n');
	write_spec_surface(fid,sub,hem,'pial',mmRes);
	fprintf(fid,'\n');
	write_spec_surface(fid,sub,hem,fs_surf,mmRes);
	fclose(fid);

	disp('running 3dVol2Surf...');	
	final_out=[tmpDir,'/',hem,'_final.niml.dset'];
	system(['3dVol2Surf ', ...
			' -spec ',surfspec, ... 
			' -surf_A smoothwm', ...
			' -surf_B pial', ...
			' -sv ',surfvol, ...
			' -grid_parent ',func3d, ...
			' -map_func ave ', ...
			' -f_steps 10 ', ...
			' -f_p1_mm -1.0 ', ...
			' -f_pn_mm 1.0 ', ...
			' -oob_value 0.0 ', ...
			' -skip_col_non_results ', ...
			' -out_niml ',final_out]);
	if h > 1
		TW(:,((h-1).*N+1):h.*N)=read_niml_binary(final_out,opsDataType,saveDataType);
	else
		TW=read_niml_binary(final_out,opsDataType,saveDataType);
	end
end

system(['rm -rf ',tmpDir]);

end

											
function [coordinates, triangles] = read_fs_ascii_mesh(filename)

fid=fopen(filename,'r');
if -1 == fid
    error(['cannot open freesurfer ascii mesh file:  ', filename]);
end

coordsonly = (nargout == 1);

line=fgetl(fid);
% should be comment line
if line(1) ~= '#'
    error('line 1 unrecognized mesh format');
end

line=fgetl(fid);
% should be num_nodes, num_triangles
nodes_tris=sscanf(line,'%d');
if length(nodes_tris) ~= 2
    error('line 2 unrecognized mesh format');
end

N = nodes_tris(1);
coordinates = fscanf(fid,'%f %f %f 0\n',[3,N]);
if ~coordsonly
    T = nodes_tris(2);
    triangles = fscanf(fid,'%f %f %f 0\n',[3,T]);
else
    triangles = [];
end
fclose(fid);

end

function make_warped_nonsphere(origCoords, warpTris, nearest_nodes, surfname)
    
fid = fopen(surfname,'w');
if -1 == fid
	surfname
    error('cannot open output mesh for writing');
end

N = size(nearest_nodes,1);
T = size(warpTris,2);
fprintf(fid,'# made by computeInterpInVolume::make_warped_nonsphere, part of connnorm\n');
fprintf(fid,'%d %d\n',N,T);
for n = 1:N
    fprintf(fid,'%f %f %f 0\n',...
        origCoords(1,nearest_nodes(n)),...
        origCoords(2,nearest_nodes(n)),...
        origCoords(3,nearest_nodes(n)));
end
for t = 1:T
    fprintf(fid,'%d %d %d 0\n',...
        warpTris(1,t),...
        warpTris(2,t),...
        warpTris(3,t));
end

fclose(fid);

end

function write_spec_surface(fid,sub,hem,state,mmRes)

fprintf(fid,'NewSurface\n');
fprintf(fid,'\tSurfaceFormat = ASCII\n');
fprintf(fid,'\tSurfaceType = FreeSurfer\n');
smoothwm_file = sprintf('%s_%s.smoothwm.connnorm.asc',sub,hem);
if (length(state) > 5) && strcmp(state(1:6),'sphere')
	fprintf(fid,'\tFreeSurferSurface = standard%dmm_%s_%s.connnorm.asc\n',mmRes,sub,hem);
else
	fprintf(fid,'\tFreeSurferSurface = %s_%s.%s.connnorm.asc\n',sub,hem,state);
end
if strcmp(state,'smoothwm')
    localDomainParent = 'SAME';
else
    localDomainParent = smoothwm_file;
end
fprintf(fid,'\tLocalDomainParent = %s\n',localDomainParent);
fprintf(fid,'\tSurfaceState = %s\n',state);
fprintf(fid,'\tEmbedDimension = 3\n');

end
