function make_warped_meshes(subjects, hems, experiment, saveSubjDir, outDir, mmRes, fs_surf, alignDir,suffix)
%function make_warped_meshes(subjects, hems,experiment, saveSubjDir, outDir, mmRes, fs_surf, alignDir)
%
%Makes smoothwm and pial meshes corresponding to the spherical mesh output by funcnorm.m
%This is done by finding the nearest nodes in the original freesurfer
%{fs_surf} (usually
%sphere.reg) mesh and using the corresponding X Y Z coordinates of the original smoothwm and
%pial meshes as nodes in the funcnorm version of those meshes. The triangulation of the mesh
%stays the same as the funcnorm.sphere, so that is copied over to make a FreeSurfer ASCII 
%surface.
%
%INPUTS:
%
%subjects: a cell array of subject initials-- each a directory in saveSubjDir
% ex: {'cb','kd','dm','mh','rb','hj'}
%hems: a cell array of the hemispheres to consider (either just lh or just rh or both)
% ex: {'lh','rh'}
%experiment: the experiment used to create the warp
% ex: 'movie5min_P1'
%saveSubjDir: the location of the subjects directory where intermediate results were saved
%  by earlier scripts in the pipeline (funcnorm_prepare.sh and funcnorm.m)
% ex: ../sample_results/subject_dir
%outDir: directory containing the final output of the funcnorm.m script, including the
%  spherical funcnormed meshes for each subject
% ex: ../sample_results/outputdir
%mmRes: the resolution of the standard mesh used to create the warp, in mm
% ex: 2
%fs_surf: the nature of the spherical surface used as a starting point for the warp, either
% 'sphere' (talairach-only) or 'sphere.reg' (aligned by cortical curvature)
%

nsubj = length(subjects);
nhem = length(hems);

if ~exist(alignDir) || isempty(alignDir)
	% Set the align dir as default
	alignDir = [outDir, 'alignment_', experiment];
end
if isempty(suffix)
    suffix='connnorm'
end

for s=1:nsubj
        sub=subjects{s};
        for h=1:nhem
                hem=hems{h};

                disp(['subject ',sub,' ',hem,' hemisphere...']);
                
                orig_prefix=[saveSubjDir,sub,'/SUMA/',hem,'.'];
                orig_sphere=[orig_prefix,fs_surf,'.asc'];
                orig_pial=[orig_prefix,'pial.asc'];
                orig_smoothwm=[orig_prefix,'smoothwm.asc'];
                warpDir=[alignDir,'/warps/',hem,'/'];
                warp_sphere=[warpDir,'standard',num2str(mmRes),'mm_',sub,'_',hem,'.',suffix,'.asc'];

                % read in warped, low-res mesh and original, high-res mesh
                [warpCoords,warpTris] = read_fs_ascii_mesh(warp_sphere);
                origCoords = read_fs_ascii_mesh(orig_sphere);
                % Find nearest node in orig_sphere from warp_sphere
                N = size(warpCoords,2);
                if ~exist('nearest_nodes','var')
                    nearest_nodes = zeros(1, N, 'single');
                end
                disp('finding nearest nodes...');
                for n = 1:N
                    corrs = warpCoords(:, n)'*origCoords;
                    % Find node with max correlation
                    [garbage, nearest_nodes(n)] = max(corrs);
                end
          
                % use nearest nodes to get rows of X Y Z from orig_pial and orig_smoothwm
                % and tesselate to get triangles for topological section of
                % mesh
                warpPrefix = [warpDir,'/',sub,'_',hem];
                origCoords = read_fs_ascii_mesh(orig_smoothwm);
                make_warped_nonsphere(origCoords,warpTris,nearest_nodes,[warpPrefix,'.smoothwm.',suffix,'.asc']);
                origCoords = read_fs_ascii_mesh(orig_pial);
                make_warped_nonsphere(origCoords,warpTris,nearest_nodes,[warpPrefix,'.pial.',suffix,'.asc']);
                
                % make a spec file with warp_sphere, warp_pial, warp_smoothm in it
                fid = fopen([warpPrefix,'.spec'],'w');
                fprintf(fid,'# mesh generated by make_warped_meshes.m, part of %s\n',suffix);
                fprintf(fid,'\tGroup = %s_%s_%sed\n',sub,hem,suffix);
                fprintf(fid,'\tStateDef = sphere.reg\n');
                fprintf(fid,'\tStateDef = pial\n');
                fprintf(fid,'\tStateDef = smoothwm\n');
                fprintf(fid,'\n\n');
                write_spec_surface(fid,sub,hem,'smoothwm',mmRes,suffix);
                fprintf(fid,'\n');
                write_spec_surface(fid,sub,hem,'pial',mmRes,suffix);
                fprintf(fid,'\n');
                write_spec_surface(fid,sub,hem,fs_surf,mmRes,suffix);
                fclose(fid);
        end
end

end

function [coordinates, triangles] = read_fs_ascii_mesh(filename)

fid=fopen(filename,'r');
if -1 == fid
    error(['cannot open freesurfer ascii mesh file:  ', filename]);
end

coordsonly = (nargout == 1);

line=fgetl(fid);
% should be comment line
if line(1) ~= '#'
    error('line 1 unrecognized mesh format');
end

line=fgetl(fid);
% should be num_nodes, num_triangles
nodes_tris=sscanf(line,'%d');
if length(nodes_tris) ~= 2
    error('line 2 unrecognized mesh format');
end

N = nodes_tris(1);
coordinates = fscanf(fid,'%f',[4,N]);
if ~coordsonly
    T = nodes_tris(2);
    triangles = fscanf(fid,'%f',[4,T]);
else
    triangles = [];
end
fclose(fid);

end

function make_warped_nonsphere(origCoords, warpTris, nearest_nodes, surfname)
    
fid = fopen(surfname,'w');
if -1 == fid
    error('cannot open output mesh for writing');
end

N = size(nearest_nodes,2);
T = size(warpTris,2);
fprintf(fid,'# made by make_warped_meshes.m, part of funcnorm/connnorm\n');
fprintf(fid,'%d %d\n',N,T);
for n = 1:N
    fprintf(fid,'%f %f %f 0\n',...
        origCoords(1,nearest_nodes(n)),...
        origCoords(2,nearest_nodes(n)),...
        origCoords(3,nearest_nodes(n)));
end
for t = 1:T
    fprintf(fid,'%d %d %d 0\n',...
        warpTris(1,t),...
        warpTris(2,t),...
        warpTris(3,t));
end

fclose(fid);

end

function write_spec_surface(fid,sub,hem,state,mmRes,suffix)

fprintf(fid,'NewSurface\n');
fprintf(fid,'\tSurfaceFormat = ASCII\n');
fprintf(fid,'\tSurfaceType = FreeSurfer\n');
smoothwm_file = sprintf('%s_%s.smoothwm.%s.asc',sub,hem,suffix);
if (length(state) > 5) && strcmp(state(1:6),'sphere')
	fprintf(fid,'\tFreeSurferSurface = standard%dmm_%s_%s.%s.asc\n',mmRes,sub,hem,suffix);
else
	fprintf(fid,'\tFreeSurferSurface = %s_%s.%s.%s.asc\n',sub,hem,state,suffix);
end
if strcmp(state,'smoothwm')
    localDomainParent = 'SAME';
else
    localDomainParent = smoothwm_file;
end
fprintf(fid,'\tLocalDomainParent = %s\n',localDomainParent);
fprintf(fid,'\tSurfaceState = %s\n',state);
fprintf(fid,'\tEmbedDimension = 3\n');

end
